<html>
<head>
  <title>Redis 深度历险：核心原理与应用实践 - 老錢 - 掘金小册</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/307474 (zh-CN, DDL); Windows/6.1.1 (Win64);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="4212"/>
<h1>Redis 深度历险：核心原理与应用实践 - 老錢 - 掘金小册</h1>

<div>
<span><div style="text-size-adjust: 100%; font-size: 12px; word-break: break-word; text-rendering: optimizeLegibility; background-color: rgb(244, 245, 245);"><div style="overflow:hidden;"><div style="transition:all 0.3s cubic-bezier(0.4, 0, 0.2, 1);"><div style="box-sizing:border-box;background-color:rgb(230, 231, 233);"><div style="box-shadow:rgba(0, 0, 0, 0.15) 1px 1px 8px;background-color:rgb(255, 255, 255);border-radius:2px;box-sizing:border-box;"><div style="word-break: break-word; font-size: 15px;"><h1 style="font-size: 30px; margin: 35px 0px 5px; padding-bottom: 5px;"><span style="font-size: 16px; display: inline-block; min-width: 100%; position: relative;"><span style="font-size: 30px; color: rgb(51, 51, 51); font-family: -apple-system, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Arial, sans-serif; font-weight: 400; line-height: 1.5;">拓展 4：朝生暮死 —— 过期策略</span></span></h1><div style="margin-bottom: 22px; margin-top: 25px;"><span style="font-size: 15px; color: rgb(51, 51, 51); font-family: -apple-system, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Arial, sans-serif; font-weight: 400; line-height: 1.75;">Redis 所有的数据结构都可以设置过期时间，时间一到，就会自动删除。你可以想象 Redis 内部有一个死神，时刻盯着所有设置了过期时间的 key，寿命一到就会立即收割。</span></div><p style="line-height:inherit;margin-top:22px;margin-bottom:22px;"></p><div style="margin: 22px auto; text-align: center;"><div><img src="https://user-gold-cdn.xitu.io/2018/7/19/164b156918d00bbd?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" style="font-size: 11pt; color: rgb(51, 51, 51);"></img></div><div style="text-align: center; font-size: 12px; line-height: 1.6; color: rgb(144, 144, 144); margin-top: 2px;"></div></div><p style="line-height:inherit;margin-top:22px;margin-bottom:22px;"></p><div style="margin-top: 22px; margin-bottom: 22px;"><span style="font-size: 15px; color: rgb(51, 51, 51); font-family: -apple-system, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Arial, sans-serif; font-weight: 400; line-height: 1.75;">你还可以进一步站在死神的角度思考，会不会因为同一时间太多的 key 过期，以至于忙不过来。同时因为 Redis 是单线程的，收割的时间也会占用线程的处理时间，如果收割的太过于繁忙，会不会导致线上读写指令出现卡顿。</span></div><div style="margin-top: 22px; margin-bottom: 22px;"><span style="font-size: 15px; color: rgb(51, 51, 51); font-family: -apple-system, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Arial, sans-serif; font-weight: 400; line-height: 1.75;">这些问题 Antirez 早就想到了，所有在过期这件事上，Redis 非常小心。</span></div><h2 style="margin-top: 35px; margin-bottom: 10px; padding-bottom: 12px; font-size: 24px; border-bottom: 1px solid rgb(236, 236, 236);"><span style="font-size: 24px; color: rgb(51, 51, 51); font-family: -apple-system, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Arial, sans-serif; font-weight: 400; line-height: 1.5;">过期的 key 集合</span></h2><div style="margin-top: 22px; margin-bottom: 22px;"><span style="font-size: 15px; color: rgb(51, 51, 51); font-family: -apple-system, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Arial, sans-serif; font-weight: 400; line-height: 1.75;">redis 会将每个设置了过期时间的 key 放入到一个独立的字典中，以后会定时遍历这个字典来删除到期的 key。除了定时遍历之外，它还会使用惰性策略来删除过期的 key，所谓惰性策略就是在客户端访问这个 key 的时候，redis 对 key 的过期时间进行检查，如果过期了就立即删除。定时删除是集中处理，惰性删除是零散处理。</span></div><h2 style="margin-top: 35px; margin-bottom: 10px; padding-bottom: 12px; font-size: 24px; border-bottom: 1px solid rgb(236, 236, 236);"><span style="font-size: 24px; color: rgb(51, 51, 51); font-family: -apple-system, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Arial, sans-serif; font-weight: 400; line-height: 1.5;">定时扫描策略</span></h2><div style="margin-top: 22px; margin-bottom: 22px;"><span style="font-size: 15px; color: rgb(51, 51, 51); font-family: -apple-system, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Arial, sans-serif; font-weight: 400; line-height: 1.75;">Redis 默认会每秒进行十次过期扫描，过期扫描不会遍历过期字典中所有的 key，而是采用了一种简单的贪心策略。</span></div><ol style="padding-left:28px;"><li style="margin-bottom:0px;list-style:inherit;padding-left:6px;"><div><span style="font-size: 15px; color: rgb(51, 51, 51); font-family: -apple-system, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Arial, sans-serif; font-weight: 400; line-height: 1.75;">从过期字典中随机 20 个 key；</span></div></li><li style="margin-bottom:0px;list-style:inherit;padding-left:6px;"><div><span style="font-size: 15px; color: rgb(51, 51, 51); font-family: -apple-system, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Arial, sans-serif; font-weight: 400; line-height: 1.75;">删除这 20 个 key 中已经过期的 key；</span></div></li><li style="margin-bottom:0px;list-style:inherit;padding-left:6px;"><div><span style="font-size: 15px; color: rgb(51, 51, 51); font-family: -apple-system, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Arial, sans-serif; font-weight: 400; line-height: 1.75;">如果过期的 key 比率超过 1/4，那就重复步骤 1；</span></div></li></ol><div style="margin-top: 22px; margin-bottom: 22px;"><span style="font-size: 15px; color: rgb(51, 51, 51); font-family: -apple-system, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Arial, sans-serif; font-weight: 400; line-height: 1.75;">同时，为了保证过期扫描不会出现循环过度，导致线程卡死现象，算法还增加了扫描时间的上限，默认不会超过 25ms。</span></div><div style="margin-top: 22px; margin-bottom: 22px;"><span style="font-size: 15px; color: rgb(51, 51, 51); font-family: -apple-system, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Arial, sans-serif; font-weight: 400; line-height: 1.75;">设想一个大型的 Redis 实例中所有的 key 在同一时间过期了，会出现怎样的结果？</span></div><div style="margin-top: 22px; margin-bottom: 22px;"><span style="font-size: 15px; color: rgb(51, 51, 51); font-family: -apple-system, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Arial, sans-serif; font-weight: 400; line-height: 1.75;">毫无疑问，Redis 会持续扫描过期字典 (循环多次)，直到过期字典中过期的 key 变得稀疏，才会停止 (循环次数明显下降)。这就会导致线上读写请求出现明显的卡顿现象。导致这种卡顿的另外一种原因是内存管理器需要频繁回收内存页，这也会产生一定的 CPU 消耗。</span></div><div style="margin-top: 22px; margin-bottom: 22px;"><span style="font-size: 15px; color: rgb(51, 51, 51); font-family: -apple-system, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Arial, sans-serif; font-weight: 400; line-height: 1.75;">也许你会争辩说“扫描不是有 25ms 的时间上限了么，怎么会导致卡顿呢”？这里打个比方，假如有 101 个客户端同时将请求发过来了，然后前 100 个请求的执行时间都是 25ms，那么第 101 个指令需要等待多久才能执行？2500ms，这个就是客户端的卡顿时间，是由服务器不间断的小卡顿积少成多导致的。</span></div><div style="margin-top: 22px; margin-bottom: 22px;"><span style="font-size: 15px; color: rgb(51, 51, 51); font-family: -apple-system, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Arial, sans-serif; font-weight: 400; line-height: 1.75;">所以业务开发人员一定要注意过期时间，如果有大批量的 key 过期，要给过期时间设置一个随机范围，而不能全部在同一时间过期。</span></div><div style="font-size: 1em; overflow: auto; position: relative;"><div lang="py" style="border-radius: 2px; word-break: normal; font-size: 11px; overflow-x: auto; margin: 0px; background: rgb(248, 248, 248); padding: 18px 15px 12px;"><div><span style="font-size: 11px; position: absolute; right: 15px; top: 2px; color: rgba(140, 140, 140, 0.8); font-family: Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace; font-weight: 400; line-height: 1.75;">py</span><span style="font-size: 11px; color: rgb(153, 153, 136); font-family: Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace; font-weight: 400; line-height: 1.75;"># 在目标过期时间上增加一天的随机时间</span></div><div><span style="font-size: 11px; color: rgb(51, 51, 51); font-family: Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace; font-weight: 400; line-height: 1.75;">redis.expire_at(key, random.randint(</span><span style="font-size: 11px; color: teal; font-family: Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace; font-weight: 400; line-height: 1.75;">86400</span><span style="font-size: 11px; color: rgb(51, 51, 51); font-family: Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace; font-weight: 400; line-height: 1.75;">) + expire_ts)</span></div></div></div><div style="margin-top: 22px; margin-bottom: 22px;"><span style="font-size: 15px; color: rgb(51, 51, 51); font-family: -apple-system, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Arial, sans-serif; font-weight: 400; line-height: 1.75;">在一些活动系统中，因为活动是一期一会，下一期活动举办时，前面几期的很多数据都可以丢弃了，所以需要给相关的活动数据设置一个过期时间，以减少不必要的 Redis 内存占用。如果不加注意，你可能会将过期时间设置为活动结束时间再增加一个常量的冗余时间，如果参与活动的人数太多，就会导致大量的 key 同时过期。</span></div><div style="margin-top: 22px; margin-bottom: 22px;"><span style="font-size: 15px; color: rgb(51, 51, 51); font-family: -apple-system, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Arial, sans-serif; font-weight: 400; line-height: 1.75;">掌阅服务端在开发过程中就曾出现过多次因为大量 key 同时过期导致的卡顿报警现象，通过将过期时间随机化总是能很好地解决了这个问题，希望读者们今后能少犯这样的错误。</span></div><h2 style="margin-top: 35px; margin-bottom: 10px; padding-bottom: 12px; font-size: 24px; border-bottom: 1px solid rgb(236, 236, 236);"><span style="font-size: 24px; color: rgb(51, 51, 51); font-family: -apple-system, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Arial, sans-serif; font-weight: 400; line-height: 1.5;">从库的过期策略</span></h2><div style="margin-top: 22px; margin-bottom: 22px;"><span style="font-size: 15px; color: rgb(51, 51, 51); font-family: -apple-system, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Arial, sans-serif; font-weight: 400; line-height: 1.75;">从库不会进行过期扫描，从库对过期的处理是被动的。主库在 key 到期时，会在 AOF 文件里增加一条</span> <span style="color: rgb(255, 80, 44); font-family: Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace; font-weight: 400; line-height: 1.75; background-color: rgb(255, 245, 245); border-radius: 2px; overflow-x: auto; padding: 0.065em 0.4em; word-break: break-word;">del</span> <span style="font-size: 15px; color: rgb(51, 51, 51); font-family: -apple-system, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Arial, sans-serif; font-weight: 400; line-height: 1.75;">指令，同步到所有的从库，从库通过执行这条</span> <span style="color: rgb(255, 80, 44); font-family: Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace; font-weight: 400; line-height: 1.75; background-color: rgb(255, 245, 245); border-radius: 2px; overflow-x: auto; padding: 0.065em 0.4em; word-break: break-word;">del</span> <span style="font-size: 15px; color: rgb(51, 51, 51); font-family: -apple-system, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Arial, sans-serif; font-weight: 400; line-height: 1.75;">指令来删除过期的 key。</span></div><div style="margin-top: 22px; margin-bottom: 22px;"><span style="font-size: 15px; color: rgb(51, 51, 51); font-family: -apple-system, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Arial, sans-serif; font-weight: 400; line-height: 1.75;">因为指令同步是异步进行的，所以主库过期的 key 的</span> <span style="color: rgb(255, 80, 44); font-family: Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace; font-weight: 400; line-height: 1.75; background-color: rgb(255, 245, 245); border-radius: 2px; overflow-x: auto; padding: 0.065em 0.4em; word-break: break-word;">del</span> <span style="font-size: 15px; color: rgb(51, 51, 51); font-family: -apple-system, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Arial, sans-serif; font-weight: 400; line-height: 1.75;">指令没有及时同步到从库的话，会出现主从数据的不一致，主库没有的数据在从库里还存在，比如上一节的集群环境分布式锁的算法漏洞就是因为这个同步延迟产生的。</span></div></div></div></div></div></div></div><div><br/></div></span>
</div></body></html> 